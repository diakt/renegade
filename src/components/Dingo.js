import React, { useRef, useEffect, useState } from 'react';
import mapboxgl from '!mapbox-gl'; // eslint-disable-line import/no-webpack-loader-syntax
import FireUnit from './FireUnit';
import haversine from 'haversine';
import FooterElt from './FooterElt';
mapboxgl.accessToken = 'pk.eyJ1IjoiZ2F2aW5zb3V0aGVybGFuZCIsImEiOiJjbDVraG1oeWIwYTExM2RsNmM0ZHd3ZWk0In0.UKmk4t4WUjMtjfbiTeeZZg';


function Dingo() {
  const mapContainer = useRef(null);
  const map = useRef(null);
  const [lat, setLat] = useState(37.0902);
  const [lng, setLng] = useState(-95.7129);
  const [zoom, setZoom] = useState(3);


  //states
  const [userLatLong, setUserLatLong] = useState([]);
  const [fireData, setFireData] = useState([])
  const [sortedFireData, setSortedFireData] = useState([])
  const [footerText, setFooterText] = useState("Select a fire to see more.")







  //functions
  function getuserLatLong() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        function (position) {
          setUserLatLong([position.coords.latitude, position.coords.longitude])
        },
        function () {
          setFooterText("Waiting for user to enable location data. I assure you that I am not competent enough to abuse your privacy.");
        })
    }
    else {
      //No browser support, full fail
      setFooterText("Unfortunately, this browser does not support geolocation. Try again on another computer.");
    }
  }

  const setQuery = (latitude, longitude, areaSizeParameter) => {
    //2k cap on requests, so this is a live filter with a customized request url
    //latitude is 0 to +-45, defines y coordinate, while longitude is -90 to 90, defines x coordinate
    //in western hemisphere, increasing magnitude of neg goes west
    //The number function is used as I had an interesting bug
    const xmin = Number(longitude) - Number(areaSizeParameter)
    const ymin = Number(latitude) - Number(areaSizeParameter) / 2
    const xmax = Number(longitude) + Number(areaSizeParameter)
    const ymax = Number(latitude) + Number(areaSizeParameter) / 2

    const finalURL = `https://services3.arcgis.com/T4QMspbfLg3qTGWY/ArcGIS/rest/services/CY_WildlandFire_Locations_ToDate/FeatureServer/0/query?where=1%3D1&objectIds=&time=&geometry=%7Bxmin%3A+${xmin}%2C+ymin%3A+${ymin}%2C+xmax%3A+${xmax}%2C+ymax%3A+${ymax}%7D%0D%0A&geometryType=esriGeometryEnvelope&inSR=&spatialRel=esriSpatialRelContains&resultType=none&distance=0.0&units=esriSRUnit_Meter&relationParam=&returnGeodetic=false&outFields=*&returnGeometry=true&featureEncoding=esriDefault&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=&defaultSR=&datumTransformation=&applyVCSProjection=false&returnIdsOnly=false&returnUniqueIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnQueryGeometry=false&returnDistinctValues=true&cacheHint=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&having=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&returnExceededLimitFeatures=true&quantizationParameters=&sqlFormat=none&f=pjson&token=`
    return finalURL
  }



  function getFireData(latitude, longitude) {
    //in this function, we fetch our data with a query generated by a url for a certain location
    const url = setQuery(latitude, longitude, 3)
    fetch(url)
      .then((result) => { return result.json() })
      .then((data) => {
        setFireData((data.features).filter(element =>
          (element.attributes.DiscoveryAcres != null || element.attributes.DiscoveryAcres != null || element.attributes.CalculatedAcres != null)
        ))
      })
      .catch((err) => console.log(err))
  }

  const orderFiresByDistance = () => {
    //in this function, we add some additional features to our elements in our fire data set
    //we also double store, but that is for a later intended functionality
    const user_location = {
      latitude: userLatLong[0], //userLatLong[0]
      longitude: userLatLong[1] //userLatLong[1]
    }
    const sortedFireData = fireData;
    let difference = null;

    //note that the haversine function is a function to calculate distance across an oblate spheroid from two lat-long points
    sortedFireData.forEach((element) => {
      difference = haversine(user_location, { latitude: element.geometry.y, longitude: element.geometry.x }, { unit: 'mile' })
      element['difference'] = difference
      if (element.attributes.DailyAcres == null && element.attributes.DailyAcres == null) {
        element['sizeColor'] = "grey"
      }
      else if (element.attributes.DailyAcres > 0 && element.attributes.DailyAcres < 10) {
        element['sizeColor'] = "green"
      }
      else if (element.attributes.DailyAcres > 10 && element.attributes.DailyAcres < 100) {
        element['sizeColor'] = "blue"
      }
      else if (element.attributes.DailyAcres > 100 && element.attributes.DailyAcres < 1000) {
        element['sizeColor'] = "yellow"
      }
      else if (element.attributes.DailyAcres > 1000 && element.attributes.DailyAcres < 10000) {
        element['sizeColor'] = "orange"
      }
      else if (element.attributes.DailyAcres > 10000 && element.attributes.DailyAcres < 100000) {
        element['sizeColor'] = "red"
      }

      if (element.attributes.OrganizationalAssessment != null) {
        element['sizeColor'] = "purple"
      }

    })
    sortedFireData.sort((e1, e2) => e1.difference - e2.difference)
    setSortedFireData(sortedFireData)
  }

  function addFireMarkers() {
    //in this function, we add our markers to the map
    for (let i = 0; i < sortedFireData.length; i++) {
      const fire = sortedFireData[i]
      const fireMarker = new mapboxgl.Marker({
        color: fire.sizeColor,
        size: "small",
        draggable: false,
        scale: 0.5,
        anchor: "bottom"
      })
        .setLngLat([fire.geometry.x, fire.geometry.y])
        .addTo(map.current)

    }
  }
  function addFireLayer() {
    //in this function, we add our fire layer to the map
    map.current.addLayer({
      'id': 'fireLayer',
      'type': 'fill',
      'source': {
        'type': 'geojson',
        'data': {
          'type': 'FeatureCollection',
          'features': sortedFireData
        }
      },
      'layout': {},
      'paint': {
        'fill-color': '#ff0000',
        'fill-opacity': 0.5
      }
    });
  }

  function addFireSymbolLayer() {
    //in this function, we add our fire layer to the map

    map.current.addLayer({
      'id': 'fireSymbolLayer',
      'type': 'circle',
      'source': {
        'type': 'geojson',
        'data': {
          'type': 'FeatureCollection',
          'features': sortedFireData
        }

      },
      'layout': {},
      'paint': {
        'circle-color': '#ff0000',
        'circle-opacity': 0.5,
        'circle-radius': 5
      },
      'visibility': 'visible'
    });

  }












  //useEffect hooks to run functions on page load and when data changes 


  useEffect(() => {
    if (map.current) return; // initialize map only once
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/dark-v10',
      center: [lng, lat],
      zoom: zoom,
      key: process.env.REACT_APP_MAPBOX_KEY,
      zoom: 3,

    });
    map.current.addControl(

      new mapboxgl.GeolocateControl({
        //this feature is for controlling zoom
        fitBoundsOptions: { maxZoom: 8 },
        positionOptions: {
          enableHighAccuracy: true
        },
        trackUserLocation: true,
        showUserHeading: true,
      })

    );
    map.current.addControl(new mapboxgl.NavigationControl(), 'top-right');



  });


  useEffect(() => {
    if (!map.current) return; // wait for map to initialize
    map.current.on('move', () => {
      setLng(map.current.getCenter().lng.toFixed(4));
      setLat(map.current.getCenter().lat.toFixed(4));
      setZoom(map.current.getZoom().toFixed(2));
    });
  });


  //side effects
  //fires on render of page, gets user location once
  useEffect(() => {
    getuserLatLong()

  }, []);

  //chains after we get userlocation to get our data, but also if we submit a lat/long through page form.
  useEffect(() => {

    if (!userLatLong) {
    }
    else {
      setFooterText("Select a fire to see more.")
      getFireData(userLatLong[0], userLatLong[1])

    }
  }, [userLatLong]);



  setTimeout(() => {
    orderFiresByDistance()

  }, 50);

  setTimeout(() => {
    addFireMarkers()
    // addFireLayer()
    // addFireSymbolLayer()

  }, 2000);



  return (
    <div>
      <main>
        <div className='fires-container'>
          <div className='left-box'>
            <div className="activelatlong">

            </div>
            <section className='latlong-in-leftbar'>
              <h3 className="fire-header">Current location:</h3>
              <p>Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}</p>
            </section>

            <h3 className="left-section-title"> Local fires:</h3>
            {sortedFireData.map((element) => {
              return (
                <FireUnit
                  key={element.attributes.OBJECTID}
                  element={element} />
              )
            })}
          </div> {/* end left-box */}

          {/* <div className='mapbox-container-map'> */}
          <div ref={mapContainer} className='mapbox-container-map'>

            <div ref={mapContainer} className="map-container" />
          </div>

        </div>

      </main >
      <footer>

        <FooterElt footerText={footerText} />
      </footer>
    </div >
  )
}
export default Dingo;